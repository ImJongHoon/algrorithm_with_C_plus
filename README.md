008. 처음 떠올린 생각: postfix, prefix -> stack. 코드 의도는 맞음.
강좌에서 소개한 방식: 괄호 알고리즘에 따른 for문과 break 방식.

009. 처음 떠올린 생각: 제한시간 1초가 달려있는거 보니 단순히 반복문으로 50000 자연수의 모든 약수를 출력하는 건 어려울거라고 생각함.
약수의 약수로 조합을 해서 약수의 갯수를 구하는 수식이 있는가? (배낭문제처럼 이전 약수를 저장했다가 사용할 수 있는가?)
강좌에서 소개한 방식: n^2의 시간복잡도로는 1초안에 풀 수 없는게 맞음.
n개의 배열을 만들고 배수를 더해서 출력하는 방식으로 약수 구하기.

-> 방향성 자체는 맞음. 방식을 못 떠올렸을 뿐.
항상 기억할 점은, 시간을 줄이고자 하면 다른 자원을 더 써서 해결하는 경우가 많다. 그리고 그것이 메모리인 경우가 많다.

010. 각 자연수의 자리수 합 - 입력한 자연수 각자가 숫자로 쪼개서 덧셈. 어렵지 않은 알고리즘이고 함수를 쪼개서 쓰는 방식을 이야기하기 위해서 준비된 문제인듯함.

%연산자는 %10으로 1의자리수를 가져올 수 있고, 10씩 나눠서 일의자리 수를 앞당길 수 있음을 기억하기.

011. (첫인상)
이중 반복문(for이랑 while) : %로 자리수를 줄여서 0이 나올때까지 count
또는
100000까지 if문으로 입력 숫자가 n이상이면 (1 * 9) + (2 * 90) ... 하고 input 값에서 앞의 숫자들을 빼고 계산ㄴ

012. (첫인상)
얘는 이중 반복문으로 했을 때 좀 오래걸릴 것 같다. 그렇다고 일일히 다 하는 건 좀 아님.
일단 이중 반복문밖에 안 떠오름
아니면 반복문 하나에 if문인데 거꾸로 써나가서 몇~몇 사이는 n씩 오르도록 설계

013. (첫인상)
0부터 9까지 배열을 만들고
100자리 자연수 입력을 어케받음?
입력 받고 나서는 100자리부터 점점 줄여가면서 %를 하고, 0이 안 나온 시점부터 카운팅을 시작한다.(if문으로 체크)

014. (첫 인상)
뒤집는 함수는 먼저 0이 끝날 때까지 처음에 0 무시하면서 %10과 /10 반복.
변환한 수는 처음에 저장한 배열에 저장.
소수인지 확인하는 isPrime은 전역으로 생성된 배열에서 제껴주는 방식을 사용하자.
<br/>
###### (Solution)
s = res*10 + num
이러한 코드 방식으로 짜면 1의 자리로 넣어주는게 가능하다.
이 방식을 사용하면 0 검사를 할 필요도 없다.

또 소수 거를 때는 하나의 숫자당 소수 판단 함수의 시간 복잡도는 O(n)이다. 반복문 하나로도 구현 가능.
<br/>

015. (첫인상)
이전 실습에서 썼던 방식대로 배열을 만들고 배수들을 전부 제끼는 방법 사용.

(solution?)
이중 for를 돌되, 소수인지 검사하는 숫자를 루트 안에 넣어서 반복 횟수 자체를 줄여버림.

16. 길이가 같은 두 단어 입력시 그 구성이 같은지 판단.
(첫인상)
26 * 2 크기의 배열 만들고 아스키 코드를 통해 1씩 카운팅해서 두 배열 비교하기.

(배운 것)
string은 끝에 null 문자가 안옴???

17. 
(배운것)
scanf("%d %d", &a, &b) 로 두개씩 받기

18. (첫인상)
for문 안에 if문
if문은 if(M초과시){count++} else{max_count와 count 비교, 이후 count = 0 으로 초기화}

19. (첫인상)
작다 크다의 상대적인 개념을 잘 활용할 수 있어야 할듯.
단순 for문으로 학생들을 비교하여 찾되, 분노 유발자가 아니게되는 그 순간, break되는 그 순간에 그 큰 학생은 자신의 앞에 있는 모든 학생들보다 큰 것이기 때문에
거기까지는 뛰어넘을 수 있다. (더 효율적인 코드)
최악의 시간복잡도는 내림차순
(배운 것)
뒤에서부터 생각하라!
뒤에서부터 센경우 max값이 나올때마다 그 사람은 분노유발자이다. 뒤에서부터 센 경우 max를 갱신하는 경우, 여태까지 셌던 애들보다 모두 크다는 소리이기 때문.
그것이 곧 분노 유발자이다.

-> 추가로 생각해볼 것.
분노유발자를 판별할 때, 맨 뒷사람은 '절대' 분노유발자가 아니다. 이런 절대로 ~인것을 기준으로 코드를 짜는 방식을 생각해보는 게 좋을 것 같다.

20. (첫인상)
if문으로 쳐도 7가지 경우의 수( 같은 숫자를 내는 if, A가 1일 때 이기고 지고 2일때...) 밖에 없는데 그냥 if문 써서 출력하면 된다.
(배운것)
경우의 수를 7가지 할 필요가 없었다.
비기는 경우 if,
elseif로 A가 이기는 경우 3가지
그리고 else로 나머지 모든 경우를 따져서 총 5가지 경우의 수로 계산 가능

21. (첫인상)
기능 구현 자체가 난이도가 있는 것은 아니나, 구현 요구사항이 많기 때문에 타임어택으로 구현해보아야겠다.
무슨 기능을 구현할지 먼저 정해두고 도전하기.

22. (첫인상)
배열의 길이가 최대 10만. 길다. timeout을 조심해야 함. -> 이걸 확실히 믿었어야 함.
(근거가 있어도 혹시나? 하게되면 공부의 의미가 퇴색됨)
->단순 for문 노가다 이외에는 방법이 없어보임. but for문 노가다도 O(n)이기 때문에 문제 없을듯.

(배운것)
###### 배열의 구간합 문제라고 한다.
구간 k가 배열의 길이 N까지 늘어날 수 있기 때문에 이는 이중 for문이 된다.(k가 늘어날수록 밖의 반복문 횟수가 줄어들긴 하지만, 충분하지 않은듯 함.)

배열의 구간합에서 for문을 한번 도는 방법?

이동하면서 동시에 계산하기.

23. (첫인상)
자연수의 갯수 10만 = 이중 반복문이 되지 않도록한다.
단순 for문으로 배열 arr[i] 와 arr[i+1] 비교하고 count하면 단순히 반복문으로 해결될듯.


24. (첫인상)
기능 구현이 어려워보이나 n이 100까지 이므로 time걱정은 좀 덜고 구현 자체에 집중
배열을 두개 만든다.
input을 받는 배열하나, N크기의 배열 하나.
N[0]은 1을 넣어두고 나머지는 모두 0을 넣어둔다.
index가 곧 나온 차이이다.
input 배열을 돌면서 둘의 차이를 구하고, index배열에서 나왔는지 넣어준다.
맨 마지막에 N arr을 돌면서 0이 하나도 없으면 Yes, 있으면 No 출력.

(풀이) 13분 43초
개선점: 차이를 검출하는 배열을 전부 다 넣고 검사하는 게 아니라, 넣을 때마다 검사를 해주는게 효율적.
이미 1일때 또 1인 경우 NO를 출력할수도 있고,
차이가 너무 크게 나면 선언한 배열의 index를 초과하여 접근할수도 있다.

25. (첫인상)
구조체 + 정렬 알고리즘?
이거 한김에 정렬 알고리즘 하나 짜고, 라이브러리 사용법도 봐두자.

(풀이 피드백)
문제를 항상 코딩 가능한 형태로 치환해서 생각하자.
등수를 정한다 == 특정 개체보다 숫자가 큰 개체가 몇 개가 있는지 파악한다. (내 위가 몇개인가 파악)

26. (첫인상)
해결 가능한 형태로 치환 : 숫자 배열에서 자신보다 index가 앞에 있는 숫자 중, 크기가 자신보다 큰 숫자가 몇개 있는가?
for문 돌면서 큰 만큼 ++ 해줘서 늘려주면 됨.

다만 이중for문이 됨.

(풀이 피드백)
n이 커져서 자신의 이전 배열들에서 자기보다 큰 수를 찾아야 된다면
이중 for문 말고 병합정렬을 사용해서 nlog(n) 으로 줄여줘야 함.

27. 

28. 

29. 

30. 

31. 